{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { clamp, focusWithoutScrolling, mergeProps, useGlobalListeners } from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from \"./utils\";\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from \"./useMove\";\nimport { isRTL } from '@react-native-aria/utils';\n\nexport function useSliderThumb(opts, state) {\n  var _opts$ariaLabelledby;\n  var index = opts.index,\n    isRequired = opts.isRequired,\n    isDisabled = opts.isDisabled,\n    validationState = opts.validationState,\n    trackLayout = opts.trackLayout,\n    inputRef = opts.inputRef;\n  var isVertical = opts.orientation === 'vertical';\n  var direction = isRTL() ? 'rtl' : undefined;\n  var _useGlobalListeners = useGlobalListeners(),\n    addGlobalListener = _useGlobalListeners.addGlobalListener,\n    removeGlobalListener = _useGlobalListeners.removeGlobalListener;\n  var labelId = sliderIds.get(state);\n  var _useLabel = useLabel(_objectSpread(_objectSpread({}, opts), {}, {\n      'id': getSliderThumbId(state, index),\n      'aria-labelledby': (labelId + \" \" + ((_opts$ariaLabelledby = opts['aria-labelledby']) !== null && _opts$ariaLabelledby !== void 0 ? _opts$ariaLabelledby : '')).trim()\n    })),\n    labelProps = _useLabel.labelProps,\n    fieldProps = _useLabel.fieldProps;\n  var value = state.values[index];\n  var focusInput = useCallback(function () {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n  var isFocused = state.focusedThumb === index;\n  useEffect(function () {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n  var stateRef = useRef(null);\n  stateRef.current = state;\n  var reverseX = direction === 'rtl';\n  var currentPosition = useRef(null);\n  var _useMove = useMove({\n      onMoveStart: function onMoveStart() {\n        currentPosition.current = null;\n        state.setThumbDragging(index, true);\n      },\n      onMove: function onMove(_ref) {\n        var deltaX = _ref.deltaX,\n          deltaY = _ref.deltaY,\n          pointerType = _ref.pointerType;\n        var size = isVertical ? trackLayout.height : trackLayout.width;\n        if (currentPosition.current == null) {\n          currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n        }\n        if (pointerType === 'keyboard') {\n          var delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n          currentPosition.current += delta * size;\n          stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n        } else {\n          var _delta = isVertical ? deltaY : deltaX;\n          if (isVertical || reverseX) {\n            _delta = -_delta;\n          }\n          currentPosition.current += _delta;\n          stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n        }\n      },\n      onMoveEnd: function onMoveEnd() {\n        state.setThumbDragging(index, false);\n      }\n    }),\n    moveProps = _useMove.moveProps;\n\n  state.setThumbEditable(index, !isDisabled);\n  var _useFocusable = useFocusable(mergeProps(opts, {\n      onFocus: function onFocus() {\n        return state.setFocusedThumb(index);\n      },\n      onBlur: function onBlur() {\n        return state.setFocusedThumb(undefined);\n      }\n    }), inputRef),\n    focusableProps = _useFocusable.focusableProps;\n  var currentPointer = useRef(undefined);\n  var onDown = function onDown(id) {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n  var onUp = function onUp(e) {\n    var _e$pointerId, _e$changedTouches;\n    var id = (_e$pointerId = e.pointerId) !== null && _e$pointerId !== void 0 ? _e$pointerId : (_e$changedTouches = e.changedTouches) === null || _e$changedTouches === void 0 ? void 0 : _e$changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': function onChange(e) {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(moveProps, {\n      onMouseDown: function onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown();\n      },\n      onPointerDown: function onPointerDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown(e.pointerId);\n      },\n      onTouchStart: function onTouchStart(e) {\n        onDown(e.changedTouches[0].identifier);\n      }\n    }) : {},\n    labelProps: labelProps\n  };\n}","map":{"version":3,"sources":["useSliderThumb.web.ts"],"names":["clamp","focusWithoutScrolling","mergeProps","useGlobalListeners","getSliderThumbId","sliderIds","useCallback","useEffect","useRef","useFocusable","useLabel","useMove","isRTL","useSliderThumb","opts","state","index","isRequired","isDisabled","validationState","trackLayout","inputRef","isVertical","orientation","direction","undefined","addGlobalListener","removeGlobalListener","labelId","get","labelProps","fieldProps","trim","value","values","focusInput","current","isFocused","focusedThumb","stateRef","reverseX","currentPosition","moveProps","onMoveStart","setThumbDragging","onMove","deltaX","deltaY","pointerType","size","height","width","getThumbPercent","delta","step","setThumbValue","getThumbValue","setThumbPercent","onMoveEnd","setThumbEditable","focusableProps","onFocus","setFocusedThumb","onBlur","currentPointer","onDown","id","window","onUp","e","pointerId","changedTouches","identifier","inputProps","getThumbMinValue","getThumbMaxValue","getThumbValueLabel","parseFloat","target","thumbProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","onTouchStart"],"mappings":"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","sourcesContent":["import { AriaSliderThumbProps } from '@react-types/slider';\nimport {\n  clamp,\n  focusWithoutScrolling,\n  mergeProps,\n  useGlobalListeners,\n} from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from './utils';\nimport React, {\n  ChangeEvent,\n  HTMLAttributes,\n  InputHTMLAttributes,\n  LabelHTMLAttributes,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n} from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from './useMove';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: HTMLAttributes<HTMLElement>;\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>;\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>;\n}\n\ninterface SliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackLayout: any;\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>;\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: SliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackLayout,\n    inputRef,\n  } = opts;\n\n  let isVertical = opts.orientation === 'vertical';\n\n  let direction = isRTL() ? 'rtl' : undefined;\n  let { addGlobalListener, removeGlobalListener } = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const { labelProps, fieldProps } = useLabel({\n    ...opts,\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim(),\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n  let { moveProps } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({ deltaX, deltaY, pointerType }) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current =\n          stateRef.current.getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta =\n          ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) *\n          stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(\n          index,\n          stateRef.current.getThumbValue(index) + delta\n        );\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(\n          index,\n          clamp(currentPosition.current / size, 0, 1)\n        );\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    },\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const { focusableProps } = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined),\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      },\n    }),\n    thumbProps: !isDisabled\n      ? mergeProps(moveProps, {\n          onMouseDown: (e: React.MouseEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown();\n          },\n          onPointerDown: (e: React.PointerEvent<HTMLElement>) => {\n            if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n              return;\n            }\n            onDown(e.pointerId);\n          },\n          onTouchStart: (e: React.TouchEvent<HTMLElement>) => {\n            onDown(e.changedTouches[0].identifier);\n          },\n        })\n      : {},\n    labelProps,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}